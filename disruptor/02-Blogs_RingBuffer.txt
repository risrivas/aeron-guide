###########################################
# 1. What's so special about a ring buffer?
###########################################
https://trishagee.com/2011/06/22/dissecting_the_disruptor_whats_so_special_about_a_ring_buffer/

## Ring Buffer
- use it as a buffer to pass stuff from one context (one thread) to another
- an array with a pointer to the next available slot
- we keep filling up the buffer (and presumable reading from it too), the sequence keeps incrementing, wrapping around the ring
- always design the array with length as power of 2

- to find the slot in the array that the current sequence points to, use a mod operation:
sequence % array length = array index

- reliable messaging:
if current sequence is 12, and there is a read request with sequence 10, simply all the messages are sent from 10 to 12

- items in the buffer are only over-written (when wrapped) - never deleted
- decision whether "should wrap or not" is done by producer / consumer - not inside the ring buffer

- benefits:
faster as its an array - cpu cache friendly (memory striding)
can pre-allocate the ring-buffer items up front, making the objects effectively immortal => means no garbage collection
Queues usually take care of all the stuff like the start and end of the queue, adding and consuming items, and so forth
However, Ring Buffer itself isn't responsible for these things, these concerns are moved outside of the data structure

- infoQ video
https://www.infoq.com/presentations/LMAX/

####################################
# 2. How to read from a ring buffer?
####################################
https://trishagee.com/2011/06/28/dissecting_the_disruptor_how_do_i_read_from_the_ring_buffer/

ConsumerBarrier => DependencyBarrier
Consumer => EventProcessor
Entry => Event

- Consumer thread has access to ConsumerBarrier, which is created by the RingBuffer and interacts with it on behalf of the Consumer
- each consumer needs to be able to figure out which sequence number it's expecting to see next
- example:
Consumer is at 8, so expecting 9
so nextSequence = 9

- terms: waitFor(), getCursor(), WaitStrategy

Consumer calls waitFor() on the ConsumerBarrier with the sequence number it wants next:
  final long availableSeq = consumerBarrier.waitFor(nextSequence);

ConsumerBarrier calls getCursor() and gets the highest sequence number available in the ring buffer - in the example above, 12
ConsumerBarrier returns the highest sequence number available in the ring buffer
ConsumerBarrier has a WaitStrategy which it uses to decide how to wait for this sequence number

Consumer ask the ConsumerBarrier to fetch the entries 9 to 12 via getEntry(9), getEntry(10)...
As it's fetching them, the Consumer is updating its own cursor
it's easy to deal with the whole batch of entries processed (e.g. from 9-12 above) without having to fetch each one individually
NO LOCKING - multiple Consumers reading off the same RingBuffer, with no need for locks and no need for additional queues to coordinate between the different threads

Consumer classes: BatchConsumer, BatchHandler => BatchEventProcessor, EventHandler


####################################
# 3. How to write to a ring buffer?
####################################
https://trishagee.com/2011/07/04/dissecting_the_disruptor_writing_to_the_ring_buffer/

- important areas are:
not wrapping the ring
informing the consumers
batching for producers
how multiple producers work

# ProducerBarrier
- ProducerBarrier is created by the ring buffer and producer will use this to write to it

- Writing to the ring buffer involves a two-phase commit:
First, producer has to claim the next slot on the buffer
Then, when the producer has finished writing to the slot, it will call commit on the ProducerBarrier

- First, producer has to claim the next slot on the buffer
Producer call nextEntry() on the ProducerBarrier
This will return an Entry object which is basically the next slot in the ring buffer

...... its easier to directly follow the blog - instead of making notes



################################
# 4. Wiring up the dependencies
################################
https://trishagee.com/2011/07/10/dissecting_the_disruptor_wiring_up_the_dependencies/

- example code:
ConsumerBarrier consumerBarrier1 = ringBuffer.createConsumerBarrier();
BatchConsumer consumer1 = new BatchConsumer(consumerBarrier1, handler1);
BatchConsumer consumer2 = new BatchConsumer(consumerBarrier1, handler2);
ConsumerBarrier consumerBarrier2 = ringBuffer.createConsumerBarrier(consumer1, consumer2);
BatchConsumer consumer3 = new BatchConsumer(consumerBarrier2, handler3);
ProducerBarrier producerBarrier = ringBuffer.createProducerBarrier(consumer3);

- Adrian's DSL
https://www.symphonious.net/2011/07/11/lmax-disruptor-high-performance-low-latency-and-simple-too/



###################
# 5. Locks are Bad
###################
https://trishagee.com/2011/07/16/dissecting_the_disruptor_why_its_so_fast_part_one__locks_are_bad/


##############################
# 6. Magic Cache line padding
##############################
https://trishagee.com/2011/07/22/dissecting_the_disruptor_why_its_so_fast_part_two__magic_cache_line_padding/



##################################
# 7. Demystifying Memory Barriers
##################################
https://trishagee.com/2011/08/07/dissecting_the_disruptor_demystifying_memory_barriers/





########################
# Disruptor 2.0 changes
########################
https://trishagee.com/2011/08/30/disruptor_20__all_change_please/

Producer => Publisher
ProducerBarrier => PublishPort
ConsumerBarrier => DependencyBarrier
Consumer => EventProcessor
Entry => Event

.... 2.0 changes are also outdated, with 3.0 version having different class names



######################
# Mechanical Sympathy
######################

## False Sharing
https://mechanical-sympathy.blogspot.com/2011/07/false-sharing.html




